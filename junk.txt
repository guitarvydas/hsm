case 1:
create Lamp
click pwr
click pwr

lampInstance = Lamp ({})
machine Lamp = λ(~).{
  local {
    // state OFF
    enter_OFF: λ(e).{ e.fexit: ~.local.exit_OFF }
    exit_OFF: nullFunction
    handle_OFF: λ(message, e).{
      cond { (message.port == 'pwr') { ~.comp.next ('ON', e) } }
    }
    // state ON
    enter_ON: λ(e).{ e.fexit: ~.local.exit_ON }
    exit_ON: nullFunction
    handle_ON: λ(message, e).{
      cond { (message.port == 'pwr') { ~.comp.next ('OFF', e) }
      else { delegate brightness (e.child) }
      }
    }
    // Machine Lamp
    machineEnter: λ(e).{ 
      e.state = 'OFF'
      e.env.childEnv = call local.enter_OFF (~)
      ...or... e.env.childEnv = call (lookupState (~, 'OFF'), "enter", ~)
      e.fexit: local.machineExit
    }
    machineExit: λ(e).{
      exit brightness (e.child)
      e.child <- ∅
    }
  }
  ~.env = { state: ∅, delegated: ∅, inq: ∅, outq: ∅ }
  ~.comp = Component ()
  ~.rom.states = [
    { name: 'OFF', descriptor: { enter: local.enter_OFF, exit: local.exit_OFF, handle: local.handle_OFF}},
    { name: 'ON',  descriptor: { enter: local.enter_ON,  exit: local.exit_ON,  handle: local.handle_ON}}
    ]
  return ~
  }

--> lampInstance.enter () == λ(e).{ e.state <- ~.state_OFF ; e.child <- ∅ } (lampInstance)
  -->
    lampInstance.state = Lamp.state_Off
    lampInstance.child = ∅

lampInstance.inject (Message ('pwr', True, ∅))
--> lampInstance.inq.enqueue (Message ('pwr', True,  ∅))
lampInstance.inject (Message ('pwr', True, ∅))
--> lampInstance.in.enqueue (Message ('pwr', True,  ∅))


lampInstance.runToCompletion ()
--> lampInstance.isReady () --> True
--> lampInstance.step (m)
  --> m = lampInstance.inq.dequeue ()
  --> lampInstance.handle (m, lampInstance)
  [ 'OFF', ~.state_OFF ]
    -->   ~.state_OFF = λ(M ('pwr', True, ∅), lampInstance).{
            cond { (message.port == 'pwr') { ~.next ('ON', lampInstance) } }
          }
      --> { ~.next (~.state_ON, lampInstance) }
	function next (~.state_ON, lampInstance) {
	  if (lampInstance.child) { exit lampInstance.child.state (lampInstance.child) }
	  env.child = ∅
	  enter ~.state_ON (lampInstance)
        --> enter_ON (lampInstance) { pass }
	  env.state = ~.state_ON
	}
--> lampInstance.isReady () --> True
--> lampInstance.step (m)
  --> m = lampInstance.inq.dequeue ()
  --> lampInstance.handle (m, lampInstance)
  [ 'ON', ~.state_ON ]
    -->   ~.state_ON = λ(M ('pwr', True, ∅), lampInstance).{
            cond { (message.port == 'pwr') { ~.next ('OFF', lampInstance) } }
          }
      --> { ~.next (~.state_OFF, lampInstance) }
	function next (~.state_OFF, lampInstance) {
	  if (lampInstance.child) { exit lampInstance.child.state (lampInstance.child) }
	  env.child = ∅
	  enter ~.state_OFF (lampInstance)
        --> enter_OFF (lampInstance) { pass }
	  env.state = ~.state_OFF
	}
--> lampInstance.isReady () --> False
